


/* This program reads the nodetypes file and nodes.c.pat file. It generates
 * the files nodes.h and nodes.c.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>


#define MAX_TYPES	50	/* Max number of node types */
#define MAX_FIELDS	20	/* Max fields in a structure */
#define BUF_LEN		100	/* Size of charaacter buffers */

/* Field types */
#define T_NODE	1		/* Union Node *field */
#define T_NODE_LIST	2	/* NodeLsit *field */
#define T_STRING	3
#define T_INT	4		/* Int field */
#define T_OTHER	5		/* Other */
#define T_TEMP	6		/* Don't copy this field */


typedef struct {
	char *name;		/* Name of field */
	int type;		/* Type of field */
	char *decl;		/* Declaration of field */
} Field;			/* A structure field */


typedef struct {
	char *tag;		/* Structure tag */
	int numFields;	/* Number of fields in the structure */
	Field field[MAX_FIELDS];	/* The fields of the structure */
	int done;		/* Set if fully parsed */
} Struct;			/* Representing a node structure */


static int numTypes = 0;	/*Number of node types */
static char *nodeName[MAX_TYPES];	/* Names of te nodes */
static Struct *nodeSPs[MAX_TYPES];	/* Type of structure used by the node */
static int numStruct = 0;		/* Number of structures */
static Struct structs[MAX_TYPES];	/* The structures */
static Struct *currStruct;	/* Current structure */


static FILE *inFp;
static char line[1024];
static int lineNum;
static char *linePtr;

static char writer[] = "\
/*\n\
 * This file was generated by the mknodes program.\n\
 */\n\
\n";

#define equal(s1, s2)	(strcmp(s1, s2) == 0)

static void error(const char *msg, ...) {
	va_list argList;

	va_start(argList, msg);
	fprintf(stderr, "line %d: ", lineNum);
	vfprintf(stderr, msg, argList);
	putc('\n', stderr);
	va_end(argList);
	exit(2);
}

static int readLine() {
	register char *p;

	if (fgets(line, 1024, inFp) == NULL)
	  return 0;
	for (p = line; *p != '#' && *p != '\n' && *p != '\0'; ++p) {
	}
	while (p > line && (p[-1] == ' ' || p[-1] == '\t')) {
		--p;
	}
	*p = '\0';
	linePtr = line;
	++lineNum;
	if (p - line > BUF_LEN)
	  error("Line too long");
	return 1;
}

int nextField(char *buf) {
	register char *p, *q;

	p = linePtr;
	while (*p == ' ' || *p == '\t') {
		++p;
	}
	q = buf;
	while (*p != ' ' && *p != '\t' && *p != '\0') {
		*q++ = *p++;
	}
	*q = '\0';
	linePtr = p;
	return q > buf;
}

static char *saveStr(char *s) {
	register char *p;
	
	if ((p = malloc(strlen(s) + 1)) == NULL)
	  error("Out of space");
	strcpy(p, s);
	return p;
}

static void skipBlank() {
	while (*linePtr == ' ' || *linePtr == '\t') {
		++linePtr;
	}
}

static void parseField() {
	char name[BUF_LEN];
	char type[BUF_LEN];
	char decl[2 * BUF_LEN];
	Field *fp;

	if (currStruct == NULL || currStruct->done)
	  error("No current structure to add field to");
	if (! nextField(name))
	  error("No field name");
	if (! nextField(type))
	  error("No field type");
	fp = &currStruct->field[currStruct->numFields];
	fp->name = saveStr(name);
	if (equal(type, "NodePtr")) {
		fp->type = T_NODE;
		sprintf(decl, "union Node *%s", name);
	} else if (equal(type, "NodeList")) {
		fp->type = T_NODE_LIST;
		sprintf(decl, "struct NodeList *%s", name);
	} else if (equal(type, "string")) {
		fp->type = T_STRING;
		sprintf(decl, "char *%s", name);
	} else if (equal(type, "int")) {
		fp->type = T_INT;
		sprintf(decl, "int %s", name);
	} else if (equal(type, "other")) {
		fp->type = T_OTHER;
	} else if (equal(type, "temp")) {
		fp->type = T_TEMP;
	} else {
		error("Unknown type %s", type);
	}
	if (fp->type == T_OTHER || fp->type == T_TEMP) {
		skipBlank();
		fp->decl = saveStr(linePtr);
	} else {
		if (*linePtr)
		  error("Garbage at end of line");
		fp->decl = saveStr(decl);
	}
	++currStruct->numFields;
}

static void parseNode() {
	char name[BUF_LEN];
	char tag[BUF_LEN];
	Struct *sp;

	if (currStruct && currStruct->numFields > 0) 
	  currStruct->done = 1;
	nextField(name);
	if (! nextField(tag)) 
	  error("Tag expected");
	if (*linePtr != '\0')
	  error("Garbage at end of line");
	nodeName[numTypes] = saveStr(name);
	for (sp = structs; sp < structs + numStruct; ++sp) {
		if (equal(sp->tag, tag))
		  break;
	}
	if (sp >= structs + numStruct) {
		sp->tag = saveStr(tag);
		sp->numFields = 0;
		currStruct = sp;
		++numStruct;
	}
	nodeSPs[numTypes] = sp;
	++numTypes;
}

static void outSizes(FILE *cFile) {
	int i;

	fprintf(cFile, "static const short nodeSize[%d] = {\n", numTypes);
	for (i = 0; i < numTypes; ++i) {
		fprintf(cFile, "    ALIGN(sizeof(%s)), \n", nodeSPs[i]->tag);
	}
	fprintf(cFile, "};\n");
}

static void indent(int amount, FILE *fp) {
	while (amount >= 4) {
		putc('\t', fp);
		amount -= 4;
	}
	while (--amount >= 0) {
		putc(' ', fp);
	}
}

static void outFunc(FILE *cFile, int calcSize) {
	Struct *sp;
	Field *fp;
	int i;
	char tag[BUF_LEN];

	fputs("    if (n == NULL)\n", cFile);
	if (calcSize) { 
		fputs("      return;\n", cFile);
		fputs("    funcBlockSize += nodeSize[n->type];\n", cFile);
	} else { 
		fputs("      return NULL;\n", cFile);
		fputs("    new = funcBlock;\n", cFile);
		fputs("    *(char **) &funcBlock += nodeSize[n->type];\n", cFile);
	}
	fputs("    switch (n->type) {\n", cFile);
	for (sp = structs; sp < &structs[numStruct]; ++sp) {
		for (i = 0; i < numTypes; ++i) {
			if (nodeSPs[i] == sp) { 
				fprintf(cFile, "        case %s:\n", nodeName[i]);
				break;
			}
		}
		strcpy(tag, sp->tag);
		tag[0] += 32;
		for (i = sp->numFields; --i >= 1; ) {
			fp = &sp->field[i];
			switch(fp->type) {
				case T_NODE:
					if (calcSize) {
						indent(12, cFile);
						fprintf(cFile, "calcSize(n->%s.%s);\n", tag, fp->name);
					} else {
						indent(12, cFile);
						fprintf(cFile, "new->%s.%s = copyNode(n->%s.%s);\n", 
									tag, fp->name, tag, fp->name);
					}
					break;
				case T_NODE_LIST:
					if (calcSize) {
						indent(12, cFile);
						fprintf(cFile, "sizeNodeList(n->%s.%s);\n", tag, fp->name);
					} else {
						indent(12, cFile);
						fprintf(cFile, "new->%s.%s = copyNodeList(n->%s.%s);\n",
									tag, fp->name, tag, fp->name);
					}
					break;
				case T_STRING:
					if (calcSize) {
						indent(12, cFile);
						fprintf(cFile, "funcStringSize += strlen(n->%s.%s) + 1;\n", 
									tag, fp->name);
					} else {
						indent(12, cFile);
						fprintf(cFile, "new->%s.%s = nodeSaveStr(n->%s.%s);\n",
									tag, fp->name, tag, fp->name);
					}
					break;
				case T_INT:
				case T_OTHER:
					if (! calcSize) {
						indent(12, cFile);
						fprintf(cFile, "new->%s.%s = n->%s.%s;\n", 
									tag, fp->name, tag, fp->name);
					}
					break;
			}
		}
		indent(12, cFile);
		fputs("break;\n", cFile);
	}
	fputs("    };\n", cFile);
	if (! calcSize) 
	  fputs("    new->type = n->type;\n", cFile);
}

static void output(char *file) {
	FILE *hFile, *cFile, *patFile;
	Struct *sp;
	Field *fp;
	int i;
	char tag[BUF_LEN];
	char *p;

	/* nodes.h */
	if ((patFile = fopen(file, "r")) == NULL)
	  error("Can't open %s", patFile);
	if ((hFile = fopen("../nodes.h", "w")) == NULL)
	  error("Can't create nodes.h");
	if ((cFile = fopen("../nodes.c", "w")) == NULL)
	  error("Can't create nodes.c");
	fputs(writer, hFile);

	/* Defines */
	for (i = 0; i < numTypes; ++i) {
		fprintf(hFile, "#define %s %d\n", nodeName[i], i);
	}
	fputs("\n\n\n", hFile);

	fputs("union Node;\n", hFile);
	fputs("struct NodeList;\n\n\n", hFile);

	/* Structs declaration */
	for (sp = structs; sp < &structs[numStruct]; ++sp) {
		fprintf(hFile, "typedef struct {\n");
		for (i = sp->numFields, fp = sp->field; --i >= 0; ++fp) {
			fprintf(hFile, "    %s;\n", fp->decl);
		}
		fprintf(hFile, "} %s;\n\n\n", sp->tag);
	}

	/* Node declaration */
	fputs("typedef union Node {\n", hFile);
	fprintf(hFile, "    int type;\n");
	for (sp = structs; sp < &structs[numStruct]; ++sp) {
		strcpy(tag, sp->tag);
		tag[0] += 32;
		fprintf(hFile, "    %s %s;\n", sp->tag, tag);
	}
	fprintf(hFile, "} Node;\n\n\n");

	/* NodeList declaration */
	fputs("typedef struct NodeList {\n", hFile);
	fputs("    struct NodeList *next;\n", hFile);
	fputs("    Node *node;\n", hFile);
	fputs("} NodeList;\n\n\n", hFile);

	/* Functions declaration */
	fputs("Node *copyFunc(Node *);\n", hFile);
	fputs("void freeFunc(Node *);\n", hFile);

	/* nodes.c */
	fputs(writer, cFile);
	while (fgets(line, sizeof(line), patFile) != NULL) {
		for (p = line; *p == ' ' || *p == '\t'; ++p) {
		}
		if (equal(p, "%SIZES\n"))
		  outSizes(cFile);
		else if (equal(p, "%CALC_SIZE\n"))
		  outFunc(cFile, 1);
		else if (equal(p, "%COPY\n"))
		  outFunc(cFile, 0);
		else
		  fputs(line, cFile);
	}
}

int main(int argc, char **argv) {
	if (argc != 3)
	  error("Usage: mknodes file patfile\n");
	if ((inFp = fopen(argv[1], "r")) == NULL)
	  error("can't open %s", argv[1]);
	while (readLine()) {
		if (line[0] == ' ' || line[0] == '\t')
		  parseField();
		else if (line[0] != '\0')
		  parseNode();
	}
	output(argv[2]);
	return 0;
}





