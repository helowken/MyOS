
/* This program scans all the source files for code to handle various
 * special events and combines this code into one file. This (allegedly)
 * improves the structure of the program since there is no need for
 * anyone outside of a module to know that that module performs special
 * operations on particular events. The command is executed iff init.c
 * is actually changed.
 *
 * Usage: mkinit command sourceFile...
 */

#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

/* OUT_FILE is the name of the output file. Output is initially written
 * to the file OUT_TEMP, which is then moved to OUT_FILE if OUTTEMP and
 * OUT_FILE are different.
 */
#define OUT_FILE "../init.c"
#define OUT_TEMP "init.c.new"

/* A text structure is basicly just a string that grows as more characters
 * are added onto the end of it. It is implemented as a linked list of
 * blocks of characters. The routines addStr and addChar append a string
 * or a single character, respectively, to a text structure. WriteText
 * writes the contents of a text structure to a file.
 */

#define BLOCK_SIZE	512

typedef struct Block {
	struct Block *next;
	char text[BLOCK_SIZE];
} Block;

typedef struct {
	char *nextChar;
	int numLeft;
	Block *start;
	Block *last;
} Text;

/* There is one event structure for each event that mkinit handles.
 */
typedef struct {
	char *name;		/* Name of event (e.g. INIT) */
	char *routine;	/* Name of routine called on event */
	char *comment;	/* Comment describing routine */
	Text code;		/* Code for handling event */
} Event;

/* Using char[] instead of char* because Event needs constant */
static char writer[] = "\
/*\n\
 * This file was generated by the mkinit program.\n\
 */\n\
\n";

static char init[] = "\
/*\n\
 * Initialization code.\n\
 */\n";

static char reset[] = "\
/*\n\
 * This routine is called when an error or an interrupt occurs in an\n\
 * interactive shell and control is returned to the main command loop.\n\
 */\n";

static char shellProc[] = "\
/*\n\
 * This routine is called to initialize the shell to run a shell procedure.\n\
 */\n";

Event event[] = {
	{"INIT", "init", init},
	{"RESET", "reset", reset},
	{"SHELLPROC", "initShellProc", shellProc},
	{NULL, NULL}
};

char *currFile;		/* Current file */
int lineNum;		/* Current line */
char *headerFiles[200];		/* List of header files */
Text defines;		/* #define statements */
Text decls;			/* Declarations */
int amidDecls;

#define equal(s1, s2)	(strcmp(s1, s2) == 0)

static void error(char *msg) {
	if (currFile != NULL)
	  fprintf(stderr, "%s:%d: ", currFile, lineNum);
	fprintf(stderr, "%s\n", msg);
	exit(2);
}

static FILE *ckFopen(char *file, char *mode) {
	FILE *fp;

	if ((fp = fopen(file, mode)) == NULL) {
		fprintf(stderr, "Can't open %s\n", file);
		exit(2);
	}
	return fp;
}

static void *ckMalloc(size_t bytes) {
	register char *p;

	if ((p = malloc(bytes)) == NULL)
	  error("Out of space");
	return p;
}

static int match(char *name, char *line) {
	register char *p, *q;

	p = name, q = line;
	while (*p) {
		if (*p++ != *q++)
		  return 0;
	}
	if (*q != '{' && *q != ' ' && *q != '\t' && *q != '\n')
	  return 0;
	return 1;
}

static char *saveStr(char *s) {
	register char *p;

	p = ckMalloc(strlen(s) + 1);
	strcpy(p, s);
	return p;
}

static void doInclude(char *line) {
	register char *p, **pp;
	char *name;

	for (p = line; *p != '"' && *p != '<' && *p != '\0'; ++p) {
	}
	if (*p == 0)
	  error("Expeting '\"' or '<'");
	name = p;
	while (*p != ' ' && *p != '\t' && *p != '\n') {
		++p;
	}
	if (p[-1] != '"' && p[-1] != '>')
	  error("Missing terminator");
	*p = 0;

	/* Name now contains the name of the include file */
	for (pp = headerFiles; *pp && !equal(*pp, name); ++pp) {
	}
	if (*pp == NULL)
	  *pp = saveStr(name);
}

static void addChar(char c, register Text *text) {
	Block *bp;

	if (--text->numLeft < 0) {
		bp = ckMalloc(sizeof(*bp));
		if (text->start == NULL)
		  text->start = bp;
		else 
		  text->last->next = bp;
		text->last = bp;
		text->nextChar = bp->text;
		text->numLeft = BLOCK_SIZE - 1;
	}
	*text->nextChar++ = c;
}

static void addStr(register char *s, register Text *text) {
	while (*s) {
		addChar(*s++, text);
	}
}

static void doDecl(char *str, FILE *fp) {
	char line[1024];
	register char *p, *q;

	if (strcmp(str, "MKINIT\n") == 0) {	/* Start of struct/union decl */
		addChar('\n', &decls);
		do {
			++lineNum;
			if (fgets(line, sizeof(line), fp) == NULL)
			  error("Unterminated structure declaration");
			addStr(line, &decls);
		} while (line[0] != '}');
		amidDecls = 0;
	} else {	/* strlen("MKINIT") is 6 */
		if (!amidDecls)
		  addChar('\n', &decls);
		q = NULL;
		for (p = str + 6; *p != '=' && *p != '/'; ++p) {
		}
		if (*p == '=') {
			for (q = p; *q && *q != ';'; ++q) {
			}
			if (*q == 0)
			  q = NULL;
			else {
				while (p[-1] == ' ')
				  --p;
				*p = 0;
			}
		}
		addStr("extern", &decls);
		addStr(str + 6, &decls);
		if (q != NULL)
		  addStr(q, &decls);
		amidDecls = 1;
	}
}

static int goodDefine(char *line) {
	register char *p;

	if (!match("#define", line))
	  return 0;		/* Not a define */
	p = line + 7;
	while (*p == ' ' || *p == '\t') {
	  ++p; 
	}
	while (*p != ' ' && *p != '\t') {
		if (*p == '(')
		  return 0;		/* Macro definition */
		++p;
	}
	while (*p != '\n' && *p != 0) {
		++p;
	}
	if (p[-1] == '\\')
	  return 0;		/* Multi-line definition */
	return 1;
}

static void doEvent(register Event *ep, FILE *fp, char *fileName) {
	char line[1024];
	int indent;
	char *p;

	sprintf(line, "\n    /* from %s: */\n", fileName);
	addStr(line, &ep->code);
	addStr("    {\n", &ep->code);
	for (;;) {
		++lineNum;
		if (fgets(line, sizeof(line), fp) == NULL)
		  error("Unexpected EOF");
		if (equal(line, "}\n"))
		  break;
		indent = 4;
		for (p = line; *p == '\t'; ++p) {
			indent += 4;
		}
		for (; *p == ' '; ++p) {
			++indent;
		}
		if (*p == '\n' || *p == '#')
		  indent = 0;
		while (indent >= 4) {
			addChar('\t', &ep->code);
			indent -= 4;
		}
		while (indent > 0) {
			addChar(' ', &ep->code);
			--indent;
		}
		addStr(p, &ep->code);
	}
	addStr("    }\n", &ep->code);
}

/* Parse an input file.
 */
static void readFile(char *fileName) {
	FILE *fp;
	char line[1024];
	Event *ep;

	fp = ckFopen(fileName, "r");
	currFile = fileName;
	lineNum = 0;
	amidDecls = 0;
	while (fgets(line, sizeof(line), fp) != NULL) {
		++lineNum;
		for (ep = event; ep->name; ++ep) {
			if (line[0] == ep->name[0] && match(ep->name, line)) {
				doEvent(ep, fp, fileName);
				break;
			}
		}
		if (line[0] == 'I' && match("INCLUDE", line))
		  doInclude(line);
		else if (line[0] == 'M' && match("MKINIT", line))
		  doDecl(line, fp);
		else if (line[0] == '#' && goodDefine(line))
		  addStr(line , &defines);
	}
	fclose(fp);
}

/* Write the contents of a text structure to a file. 
 */
static void writeText(Text *text, FILE *fp) {
	Block *bp;

	if (text->start != NULL) {
		for (bp = text->start; bp != text->last; bp = bp->next) {
			fwrite(bp->text, sizeof(char), BLOCK_SIZE, fp);
		}
		fwrite(bp->text, sizeof(char), BLOCK_SIZE - text->numLeft, fp);
	}
}

/* Write the output to the file OUT_TEMP.
 */
static void output() {
	FILE *fp;
	char **pp;
	Event *ep;

	fp = ckFopen(OUT_TEMP, "w");
	fputs(writer, fp);
	for (pp = headerFiles; *pp; ++pp) {
		fprintf(fp, "#include %s\n", *pp);
	}
	fputs("\n\n\n", fp);
	writeText(&defines, fp);
	fputs("\n\n", fp);
	writeText(&decls, fp);
	for (ep = event; ep->name; ++ep) {
		fputs("\n\n\n", fp);
		fputs(ep->comment, fp);
		fprintf(fp, "\nvoid\n%s() {\n", ep->routine);
		writeText(&ep->code, fp);
		fprintf(fp, "}\n");
	}
	fclose(fp);
}

/* Return true if the new output file is different from the old one.
 */
 int isFileChanged() {
	register FILE *f1, *f2;
	register int c;

	if ((f1 = fopen(OUT_FILE, "r")) == NULL
		|| (f2 = fopen(OUT_TEMP, "r")) == NULL)
	  return 1;
	while ((c = getc(f1)) == getc(f2)) {
		if (c == EOF)
		  return 0;
	}
	return 1;
}

 int touch(char *file) {
	int fd;
	char c;

	if ((fd = open(file, O_RDWR)) < 0)
	  return 0;
	if (read(fd, &c, 1) != 1) {
		close(fd);
		return 0;
	}
	lseek(fd, 0L, SEEK_SET);
	write(fd, &c, 1);
	close(fd);
	return 1;
}

int main(int argc, char **argv) {
	char **ap;
	char path[PATH_MAX + 1];

	if (argc < 2)
	  error("Usage: mkinit command file...");
	headerFiles[0] = "\"shell.h\"";
	headerFiles[1] = "\"mystring.h\"";
	for (ap = argv + 2; *ap; ++ap) { 
		snprintf(path, PATH_MAX, "../%s", *ap);
		readFile(path);
	}
	output();

	unlink(OUT_FILE);
	rename(OUT_TEMP, OUT_FILE);

	return 0;
}







